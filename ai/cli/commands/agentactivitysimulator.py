"""
CLI command for AgentActivitySimulator
Generated by Advanced Feature Stub Generator
"""
import click
from typing import Optional
from rich.console import Console
from rich.table import Table
from pathlib import Path
import json
import random
from datetime import datetime, timedelta
from collections import Counter, defaultdict

console = Console()


@click.command(help="Simulate agent activities for testing and validation. "
                    "Reads optional JSON config file and prints results in chosen format.")
@click.option('--verbose', '-v', is_flag=True, help='Enable verbose output')
@click.option('--output', '-o', type=click.Choice(['json', 'table', 'plain']),
              default='table', help='Output format')
@click.option('--config', type=click.Path(exists=True), help='Configuration file (JSON)')
@click.pass_context
def agentactivitysimulator(ctx, verbose: bool, output: str, config: Optional[str]):
    """
    AgentActivitySimulator command.

    Simulates agent activity events for a configurable number of agents,
    duration, and actions. Produces summary statistics and optional event
    samples. Returns a JSON-serializable dictionary when invoked programmatically.
    """
    try:
        if verbose:
            console.print(f"[blue]Running AgentActivitySimulator command...[/blue]")

        # Default simulation configuration
        default_config = {
            "num_agents": 5,
            "duration_seconds": 60,
            "actions_per_minute": 30,
            "action_types": ["login", "search", "click", "logout", "purchase"],
            "include_events": False,
            "max_events_returned": 500,
            "seed": None
        }

        user_config = {}
        if config:
            config_path = Path(config)
            try:
                with config_path.open("r", encoding="utf-8") as f:
                    user_config = json.load(f)
                if not isinstance(user_config, dict):
                    raise click.ClickException("Configuration file must contain a JSON object at the top level.")
            except json.JSONDecodeError as jde:
                raise click.ClickException(f"Invalid JSON configuration: {str(jde)}")
            except Exception as e:
                raise click.ClickException(f"Failed to read configuration file: {str(e)}")

        # Merge config
        cfg = default_config.copy()
        cfg.update({k: v for k, v in user_config.items() if v is not None})

        # Validate config values
        try:
            num_agents = int(cfg.get("num_agents"))
            if num_agents <= 0:
                raise ValueError("num_agents must be a positive integer")
        except Exception:
            raise click.BadParameter("num_agents must be a positive integer in config or use default")

        try:
            duration_seconds = int(cfg.get("duration_seconds"))
            if duration_seconds <= 0:
                raise ValueError("duration_seconds must be a positive integer")
        except Exception:
            raise click.BadParameter("duration_seconds must be a positive integer in config or use default")

        try:
            actions_per_minute = float(cfg.get("actions_per_minute"))
            if actions_per_minute < 0:
                raise ValueError("actions_per_minute must be non-negative")
        except Exception:
            raise click.BadParameter("actions_per_minute must be a number in config or use default")

        action_types = cfg.get("action_types")
        if not isinstance(action_types, list) or not action_types:
            raise click.BadParameter("action_types must be a non-empty list in config or use default")

        include_events = bool(cfg.get("include_events"))
        max_events_returned = int(cfg.get("max_events_returned") or 500)
        seed = cfg.get("seed")
        if seed is not None:
            try:
                seed = int(seed)
            except Exception:
                raise click.BadParameter("seed must be an integer if provided")

        # Initialize RNG
        rnd = random.Random(seed)

        # Simulation window
        start_time = datetime.utcnow()
        end_time = start_time + timedelta(seconds=duration_seconds)

        # Estimate total number of events
        events_rate_per_sec = (actions_per_minute / 60.0) * num_agents
        estimated_total_events = max(0, int(round(events_rate_per_sec * duration_seconds)))

        # Generate agents
        agents = [f"agent_{i+1}" for i in range(num_agents)]

        # Generate timestamps and assign actions
        events = []
        if estimated_total_events > 0:
            for i in range(estimated_total_events):
                ts_offset = rnd.random() * duration_seconds
                timestamp = start_time + timedelta(seconds=ts_offset)
                agent = rnd.choice(agents)
                action = rnd.choices(action_types, k=1)[0]
                events.append({
                    "event_id": i + 1,
                    "agent_id": agent,
                    "timestamp": timestamp.isoformat() + "Z",
                    "action": action
                })

        # Aggregate statistics
        total_events = len(events)
        actions_counter = Counter(e["action"] for e in events)
        events_per_agent = Counter(e["agent_id"] for e in events)
        top_actions = actions_counter.most_common(5)

        avg_events_per_agent = (sum(events_per_agent.values()) / num_agents) if num_agents else 0

        summary = {
            "total_events": total_events,
            "num_agents": num_agents,
            "unique_agents_with_events": len([a for a, c in events_per_agent.items() if c > 0]),
            "avg_events_per_agent": round(avg_events_per_agent, 2),
            "top_actions": top_actions,
            "start_time": start_time.isoformat() + "Z",
            "end_time": end_time.isoformat() + "Z",
            "duration_seconds": duration_seconds,
            "estimated_total_events": estimated_total_events
        }

        # Prepare returned data
        result_data = {
            "feature": "AgentActivitySimulator",
            "status": "success",
            "config_used": {
                "num_agents": num_agents,
                "duration_seconds": duration_seconds,
                "actions_per_minute": actions_per_minute,
                "action_types": action_types,
                "include_events": include_events,
                "max_events_returned": max_events_returned,
                "seed": seed
            },
            "summary": summary
        }

        # Optionally include events (sample or full up to limit)
        if include_events or verbose:
            # Sort events by timestamp for consistency
            events_sorted = sorted(events, key=lambda e: e["timestamp"])
            if len(events_sorted) > max_events_returned:
                result_data["events_truncated"] = True
                result_data["events_returned"] = max_events_returned
                result_data["events"] = events_sorted[:max_events_returned]
            else:
                result_data["events_truncated"] = False
                result_data["events_returned"] = len(events_sorted)
                result_data["events"] = events_sorted

        # Output results based on format
        if output == 'json':
            console.print_json(data=json.dumps(result_data, default=str))
        elif output == 'table':
            table = Table(title="AgentActivitySimulator Results")
            table.add_column("Property", style="cyan", no_wrap=True)
            table.add_column("Value", style="magenta")

            table.add_row("Feature", result_data.get("feature", "AgentActivitySimulator"))
            table.add_row("Status", result_data.get("status", "unknown"))
            table.add_row("Num Agents", str(num_agents))
            table.add_row("Duration (s)", str(duration_seconds))
            table.add_row("Total Events", str(summary["total_events"]))
            table.add_row("Unique Agents With Events", str(summary["unique_agents_with_events"]))
            table.add_row("Avg Events Per Agent", str(summary["avg_events_per_agent"]))
            top_actions_str = ", ".join(f"{a}:{c}" for a, c in top_actions) if top_actions else "none"
            table.add_row("Top Actions", top_actions_str)
            table.add_row("Config File", str(config) if config else "none")
            if include_events or verbose:
                table.add_row("Events Returned", str(result_data.get("events_returned", 0)))
                table.add_row("Events Truncated", str(result_data.get("events_truncated", False)))

            console.print(table)

            # If verbose, also show a small sample of actions per agent
            if verbose:
                agent_table = Table(title="Events Per Agent (sample)")
                agent_table.add_column("Agent", style="cyan")
                agent_table.add_column("Events", style="magenta")
                for agent, count in events_per_agent.most_common(10):
                    agent_table.add_row(str(agent), str(count))
                console.print(agent_table)

        else:  # plain
            console.print(f"Feature: {result_data.get('feature')}")
            console.print(f"Status: {result_data.get('status')}")
            console.print(f"Num Agents: {num_agents}")
            console.print(f"Duration (s): {duration_seconds}")
            console.print(f"Total Events: {summary['total_events']}")
            console.print(f"Unique Agents With Events: {summary['unique_agents_with_events']}")
            console.print(f"Avg Events Per Agent: {summary['avg_events_per_agent']}")
            console.print(f"Top Actions: {', '.join(f'{a}:{c}' for a, c in top_actions) if top_actions else 'none'}")
            console.print(f"Config File: {config if config else 'none'}")
            if include_events or verbose:
                console.print(f"Events Returned: {result_data.get('events_returned', 0)}")
                console.print(f"Events Truncated: {result_data.get('events_truncated', False)}")

        if verbose:
            console.print(f"[green]✅ AgentActivitySimulator completed successfully[/green]")

        # Attach result to context for programmatic use and return it
        try:
            if ctx is not None:
                if ctx.obj is None:
                    ctx.obj = {}
                ctx.obj['agentactivitysimulator_result'] = result_data
        except Exception:
            # Non-fatal if context can't be assigned
            pass

        return result_data

    except click.ClickException as cex:
        console.print(f"[red]❌ AgentActivitySimulator: {cex.format_message()}[/red]")
        if verbose:
            console.print_exception()
        ctx.exit(1)
    except click.BadParameter as bpe:
        console.print(f"[red]❌ Invalid parameter: {str(bpe)}[/red]")
        if verbose:
            console.print_exception()
        ctx.exit(2)
    except Exception as e:
        console.print(f"[red]❌ AgentActivitySimulator failed: {str(e)}[/red]")
        if verbose:
            console.print_exception()
        ctx.exit(1)


# Export command for CLI registration
__all__ = ["agentactivitysimulator"]