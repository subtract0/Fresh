"""
CLI command for RefreshController
Generated by Advanced Feature Stub Generator
"""
import json
import sys
from datetime import datetime
from pathlib import Path
from typing import Dict, Optional, Tuple

import click
from rich.console import Console
from rich.table import Table

console = Console()


def _load_config(config_path: Optional[str]) -> Dict:
    """
    Load configuration from the provided path or stdin.

    The function currently supports JSON configuration files.
    If no path is supplied, an empty dictionary is returned.

    A path of "-" will cause the function to read JSON from stdin,
    allowing seamless integration with command chaining.

    Parameters
    ----------
    config_path : Optional[str]
        Path to the configuration file or "-" for stdin.

    Returns
    -------
    Dict
        Parsed configuration data.

    Raises
    ------
    FileNotFoundError
        If the config file path is provided but does not exist.
    ValueError
        If the file (or stdin) is not valid JSON or does not resolve to a dict.
    """
    # No configuration file supplied; return empty config
    if config_path is None:
        return {}

    # STDIN support
    if config_path == "-":
        try:
            raw_data = sys.stdin.read()
            if not raw_data.strip():
                return {}
            config_data = json.loads(raw_data)
        except json.JSONDecodeError as exc:
            raise ValueError(f"Configuration data from stdin is not valid JSON: {exc}") from exc
    else:
        path = Path(config_path)

        # Validate existence and file type
        if not path.exists() or not path.is_file():
            raise FileNotFoundError(f"Configuration file not found: {config_path}")

        try:
            with path.open("r", encoding="utf-8") as fp:
                config_data = json.load(fp)
        except json.JSONDecodeError as exc:
            raise ValueError(f"Configuration file is not valid JSON: {exc}") from exc
        except Exception as exc:  # pragma: no cover
            raise ValueError(f"Failed to read configuration file: {exc}") from exc

    # Ensure configuration is a dictionary
    if not isinstance(config_data, dict):
        raise ValueError("Top-level JSON structure must be an object (dictionary).")

    return config_data


def _perform_refresh(config: Dict, verbose: bool = False) -> Tuple[Dict, str]:
    """
    Perform the refresh action based on the provided configuration.

    The refresh process scans a directory (if provided), gathers simple
    statistics, and writes/updates a `.last_refreshed` file containing the
    current UTC timestamp.

    Parameters
    ----------
    config : Dict
        Configuration dictionary.
    verbose : bool
        Flag for verbose output.

    Returns
    -------
    Tuple[Dict, str]
        A tuple containing the result data dictionary and a status string.

    Raises
    ------
    RuntimeError
        For unexpected errors during refresh.
    """
    data_dir = config.get("data_directory")

    # Validate the data_directory parameter
    if data_dir is not None and not isinstance(data_dir, str):
        raise RuntimeError("`data_directory` must be a string path if provided.")

    # If no directory is specified, safely skip the refresh
    if not data_dir:
        return (
            {
                "feature": "RefreshController",
                "status": "skipped",
                "message": "No data_directory provided in configuration.",
                "files_processed": 0,
                "directories_scanned": 0,
                "last_refreshed": None,
            },
            "skipped",
        )

    path = Path(data_dir).expanduser()

    # Validate directory existence
    if not path.exists() or not path.is_dir():
        raise RuntimeError(f"data_directory does not exist or is not a directory: {data_dir}")

    if verbose:
        console.print(f"[blue]Scanning directory: {path.resolve()}[/blue]")

    file_count = 0
    dir_count = 0
    try:
        for p in path.rglob("*"):
            if p.is_file():
                file_count += 1
            elif p.is_dir():
                dir_count += 1
    except Exception as exc:  # pragma: no cover
        raise RuntimeError(f"Failed while scanning directory: {exc}") from exc

    # Update or create the .last_refreshed file
    timestamp = datetime.utcnow().isoformat(timespec="seconds") + "Z"
    last_refreshed_file = path / ".last_refreshed"
    try:
        last_refreshed_file.write_text(timestamp, encoding="utf-8")
    except Exception as exc:  # pragma: no cover
        raise RuntimeError(f"Failed to write .last_refreshed file: {exc}") from exc

    message = (
        f"Refreshed: processed {file_count} files "
        f"across {dir_count} sub-directories."
    )

    return (
        {
            "feature": "RefreshController",
            "status": "success",
            "message": message,
            "files_processed": file_count,
            "directories_scanned": dir_count,
            "last_refreshed": timestamp,
        },
        "success",
    )


@click.command(help="Refresh local UI/data assets and update a .last_refreshed timestamp based on a JSON configuration.")
@click.option(
    "--verbose",
    "-v",
    is_flag=True,
    help="Enable verbose output",
)
@click.option(
    "--output",
    "-o",
    type=click.Choice(["json", "table", "plain"]),
    default="table",
    show_default=True,
    help="Output format: json, table, or plain text",
)
@click.option(
    "--config",
    "-c",
    type=str,
    help="Path to JSON configuration file, or '-' to read from stdin",
)
@click.pass_context
def refreshcontroller(ctx, verbose: bool, output: str, config: Optional[str]):
    """
    RefreshController command-line interface.

    The command refreshes local UI/data assets according to the supplied
    configuration file. If a `data_directory` key is present in the JSON
    configuration, the directory is scanned for statistics and a timestamp
    file `.last_refreshed` is updated to mark the sync time.

    Examples
    --------
    Refresh a directory using a config file:
        $ fresh-ai refreshcontroller --config ./my_config.json

    Pipe JSON config via stdin:
        $ echo '{"data_directory": "./assets"}' | fresh-ai refreshcontroller -c -
    """
    try:
        if verbose:
            console.print("[cyan]Starting RefreshController…[/cyan]")

        # 1. Load configuration
        config_data = _load_config(config)

        # 2. Perform refresh logic
        result_data, status = _perform_refresh(config_data, verbose=verbose)
        result_data["config_used"] = config
        result_data["verbose"] = verbose

        # 3. Output results
        if output == "json":
            console.print_json(data=result_data)
        elif output == "table":
            table = Table(title="RefreshController Results", show_header=True, header_style="bold cyan")
            table.add_column("Property", style="cyan", no_wrap=True)
            table.add_column("Value", style="magenta")
            for key, value in result_data.items():
                table.add_row(str(key), str(value))
            console.print(table)
        else:  # plain
            for key, value in result_data.items():
                console.print(f"{key}: {value}")

        # 4. Verbose success message
        if verbose and status == "success":
            console.print("[green]✅ RefreshController completed successfully[/green]")
        elif verbose and status == "skipped":
            console.print("[yellow]ℹ️  RefreshController skipped (no action taken)[/yellow]")

        return result_data
    except (FileNotFoundError, ValueError) as cfg_err:
        console.print(f"[red]Configuration Error: {cfg_err}[/red]")
        if verbose:
            console.print_exception(max_frames=5)
        ctx.exit(2)
    except RuntimeError as run_err:
        console.print(f"[red]Runtime Error: {run_err}[/red]")
        if verbose:
            console.print_exception(max_frames=5)
        ctx.exit(3)
    except KeyboardInterrupt:
        console.print("\n[red]Operation cancelled by user.[/red]")
        ctx.exit(130)
    except Exception as exc:  # Catch-all for unexpected errors
        console.print(f"[red]❌ Unexpected error: {exc}[/red]")
        if verbose:
            console.print_exception(max_frames=5)
        ctx.exit(1)


# Export command for CLI registration
__all__ = ["refreshcontroller"]