"""
CLI command for send_message_to_parent
Generated by Advanced Feature Stub Generator
"""
import click
from typing import Optional, Dict, Any
from rich.console import Console
from rich.table import Table
from pathlib import Path
import json
import os
import sys
import socket
import time
import errno

console = Console()

def load_config(config_path: str) -> dict:
    """Load configuration from a JSON file."""
    try:
        with open(config_path, 'r', encoding='utf-8') as file:
            data = json.load(file)
            if not isinstance(data, dict):
                raise RuntimeError("Configuration file must contain a JSON object at top level.")
            return data
    except FileNotFoundError:
        raise RuntimeError(f"Configuration file not found: {config_path}")
    except json.JSONDecodeError as e:
        raise RuntimeError(f"Invalid JSON in configuration file: {str(e)}")
    except Exception as e:
        raise RuntimeError(f"Failed to load configuration: {str(e)}")

def _is_unix_socket(path: str) -> bool:
    try:
        st = os.stat(path)
        return stat.S_ISSOCK(st.st_mode)  # type: ignore
    except Exception:
        return False

def send_message_to_parent_logic(config: Optional[dict], verbose: bool) -> dict:
    """Business logic for sending a message to the parent process."""
    payload: Dict[str, Any] = {}
    start_ts = time.time()
    parent_pid = os.getppid()
    result: Dict[str, Any] = {
        "feature": "send_message_to_parent",
        "status": "failure",
        "method": None,
        "parent_pid": parent_pid,
        "socket_path": None,
        "file_path": None,
        "bytes_sent": 0,
        "error": None,
        "config_used": config,
        "verbose": verbose,
        "timestamp": time.strftime("%Y-%m-%dT%H:%M:%S", time.gmtime(start_ts))
    }

    try:
        # Build message payload
        default_message = "Hello, Parent Process!"
        message = default_message
        if config and isinstance(config, dict):
            if "message" in config:
                message = str(config["message"])
        payload = {
            "message": message,
            "from_pid": os.getpid(),
            "to_pid": parent_pid,
            "timestamp": start_ts,
            "meta": {
                "source": "child_process",
                "verbose": bool(verbose)
            }
        }

        if verbose:
            console.print(f"[blue]Prepared payload:[/blue] {json.dumps(payload, indent=2)}")

        # Determine socket path from config or environment
        socket_path = None
        env_socket = os.environ.get("MOTHER_AGENT_PARENT_SOCKET")
        if config and isinstance(config, dict):
            socket_path = config.get("parent_socket") or env_socket
        else:
            socket_path = env_socket

        # Attempt UNIX domain socket send if path provided
        if socket_path:
            socket_path = str(socket_path)
            result["socket_path"] = socket_path
            try:
                if verbose:
                    console.print(f"[blue]Attempting to connect to UNIX socket at: {socket_path}[/blue]")
                sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                sock.settimeout(2.0)
                try:
                    sock.connect(socket_path)
                    data_bytes = json.dumps(payload).encode("utf-8")
                    total_sent = 0
                    while total_sent < len(data_bytes):
                        sent = sock.send(data_bytes[total_sent:])
                        if sent == 0:
                            raise RuntimeError("Socket connection broken")
                        total_sent += sent
                    result["bytes_sent"] = total_sent
                    result["method"] = "unix_socket"
                    result["status"] = "success"
                    if verbose:
                        console.print(f"[green]Sent {total_sent} bytes to parent socket[/green]")
                finally:
                    try:
                        sock.close()
                    except Exception:
                        pass
                return result
            except FileNotFoundError:
                if verbose:
                    console.print(f"[yellow]Socket file not found at {socket_path}; will fallback to file write[/yellow]")
            except socket.timeout:
                if verbose:
                    console.print(f"[yellow]Timeout connecting to socket at {socket_path}; will fallback to file write[/yellow]")
            except Exception as e:
                # If socket fails, fallback to file method
                if verbose:
                    console.print(f"[yellow]Socket send failed: {e}; falling back to file write[/yellow]")
                result["error"] = str(e)

        # Fallback: append message to a file in /tmp identified by parent pid
        file_path = None
        if config and isinstance(config, dict):
            file_path = config.get("parent_message_file")
        if not file_path:
            file_path = f"/tmp/motheragent_parent_{parent_pid}.msg"
        result["file_path"] = file_path

        try:
            p = Path(file_path)
            p.parent.mkdir(parents=True, exist_ok=True)
            # Append a JSON line atomically by opening in append mode
            line = json.dumps({
                "payload": payload,
                "delivered_at": time.time()
            }, separators=(",", ":"), ensure_ascii=False)
            with p.open("a", encoding="utf-8") as fh:
                fh.write(line + "\n")
            result["bytes_sent"] = len(line.encode("utf-8"))
            result["method"] = "file_append"
            result["status"] = "success"
            if verbose:
                console.print(f"[green]Appended message to file {file_path} ({result['bytes_sent']} bytes)[/green]")
            return result
        except PermissionError as e:
            err = f"Permission denied writing to file {file_path}: {e}"
            result["error"] = err
            if verbose:
                console.print(f"[red]{err}[/red]")
            raise RuntimeError(err)
        except Exception as e:
            err = f"Failed to write message to file {file_path}: {e}"
            result["error"] = err
            if verbose:
                console.print(f"[red]{err}[/red]")
            raise

    except Exception as e:
        result["status"] = "failure"
        if result.get("error") is None:
            result["error"] = str(e)
        return result

@click.command(help="Send a message to the parent process. Uses a UNIX domain socket if provided via config or MOTHER_AGENT_PARENT_SOCKET env var, otherwise writes to /tmp.")
@click.option('--verbose', '-v', is_flag=True, help='Enable verbose output')
@click.option('--output', '-o', type=click.Choice(['json', 'table', 'plain']), 
              default='table', help='Output format')
@click.option('--config', type=click.Path(exists=True, dir_okay=False, readable=True), help='Path to JSON configuration file')
@click.pass_context
def send_message_to_parent(ctx, verbose: bool, output: str, config: Optional[str]):
    """
    send_message_to_parent command.

    Send a message to the parent process with optional configuration.
    """
    try:
        if verbose:
            console.print(f"[blue]Running send_message_to_parent command...[/blue]")

        config_data = None
        if config:
            config_data = load_config(config)

        result_data = send_message_to_parent_logic(config_data, verbose)

        # Output results based on format
        if output == 'json':
            console.print_json(data=json.dumps(result_data, indent=2))
        elif output == 'table':
            table = Table(title=f"send_message_to_parent Results")
            table.add_column("Property", style="cyan")
            table.add_column("Value", style="magenta")

            for key, value in result_data.items():
                # Serialize complex objects compactly
                if isinstance(value, (dict, list)):
                    display = json.dumps(value, ensure_ascii=False)
                else:
                    display = str(value)
                table.add_row(str(key), display)

            console.print(table)
        else:  # plain
            for key, value in result_data.items():
                if isinstance(value, (dict, list)):
                    console.print(f"{key}: {json.dumps(value, ensure_ascii=False)}")
                else:
                    console.print(f"{key}: {value}")

        if verbose and result_data.get("status") == "success":
            console.print(f"[green]✅ send_message_to_parent completed successfully[/green]")
        elif result_data.get("status") != "success":
            console.print(f"[red]❌ send_message_to_parent reported failure[/red]")
            if verbose and result_data.get("error"):
                console.print(f"[red]Error: {result_data.get('error')}[/red]")
            ctx.exit(1)

    except Exception as e:
        console.print(f"[red]❌ send_message_to_parent failed: {str(e)}[/red]")
        if verbose:
            console.print_exception()
        ctx.exit(1)

# Export command for CLI registration
__all__ = ["send_message_to_parent"]