"""
API endpoint for MemoryIntegrationConfig
Generated by Advanced Feature Stub Generator
"""

import asyncio
from datetime import datetime
from typing import Optional, Dict, Any

from fastapi import APIRouter, HTTPException
from pydantic import BaseModel, Field, validator

router = APIRouter()

# In-memory store for integration configurations
_MEMORY_INTEGRATION_CONFIG_STORE: Dict[str, Dict[str, Any]] = {}
_STORE_LOCK = asyncio.Lock()


class MemoryIntegrationConfigRequest(BaseModel):
    """Request model for MemoryIntegrationConfig."""
    integration_name: str = Field(..., description="Unique name of the integration")
    action: str = Field(
        "get",
        description="Action to perform on the integration configuration",
        example="create",
    )
    config: Optional[Dict[str, Any]] = Field(
        None, description="Configuration data for the integration"
    )

    @validator("action")
    def validate_action(cls, v: str) -> str:
        allowed_actions = {"create", "update", "delete", "get"}
        if v not in allowed_actions:
            raise ValueError(f"Action must be one of {allowed_actions}")
        return v

    @validator("config", always=True)
    def validate_config_presence(cls, v: Optional[Dict[str, Any]], values: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """
        Ensure that 'config' is provided for actions that require it.
        """
        if values.get("action") in {"create", "update"} and v is None:
            raise ValueError("Field 'config' is required for 'create' and 'update' actions.")
        return v


class MemoryIntegrationConfigResponse(BaseModel):
    """Response model for MemoryIntegrationConfig."""
    success: bool
    message: str
    data: Optional[Dict[str, Any]] = None
    timestamp: datetime = Field(default_factory=datetime.utcnow)


@router.post(
    "/api/v1/MemoryIntegrationConfig",
    response_model=MemoryIntegrationConfigResponse,
    tags=["Memory Integration Config"],
)
async def memoryintegrationconfig_endpoint(
    request: MemoryIntegrationConfigRequest,
) -> MemoryIntegrationConfigResponse:
    """
    Handle create, update, delete and retrieval of memory integration configurations.

    Actions:
    - create: Adds a new integration configuration.
    - update: Updates an existing integration configuration.
    - delete: Removes an existing integration configuration.
    - get:    Retrieves an existing integration configuration.
    """
    try:
        async with _STORE_LOCK:
            integration_name = request.integration_name
            action = request.action
            config_data = request.config

            if action == "create":
                if integration_name in _MEMORY_INTEGRATION_CONFIG_STORE:
                    raise HTTPException(
                        status_code=400,
                        detail=f"Integration '{integration_name}' already exists.",
                    )
                _MEMORY_INTEGRATION_CONFIG_STORE[integration_name] = config_data or {}
                message = f"Integration '{integration_name}' created successfully."
                data = _MEMORY_INTEGRATION_CONFIG_STORE[integration_name]

            elif action == "update":
                if integration_name not in _MEMORY_INTEGRATION_CONFIG_STORE:
                    raise HTTPException(
                        status_code=404,
                        detail=f"Integration '{integration_name}' not found.",
                    )
                _MEMORY_INTEGRATION_CONFIG_STORE[integration_name].update(config_data or {})
                message = f"Integration '{integration_name}' updated successfully."
                data = _MEMORY_INTEGRATION_CONFIG_STORE[integration_name]

            elif action == "delete":
                if integration_name not in _MEMORY_INTEGRATION_CONFIG_STORE:
                    raise HTTPException(
                        status_code=404,
                        detail=f"Integration '{integration_name}' not found.",
                    )
                deleted_config = _MEMORY_INTEGRATION_CONFIG_STORE.pop(integration_name)
                message = f"Integration '{integration_name}' deleted successfully."
                data = {"deleted_config": deleted_config}

            else:  # action == "get"
                if integration_name not in _MEMORY_INTEGRATION_CONFIG_STORE:
                    raise HTTPException(
                        status_code=404,
                        detail=f"Integration '{integration_name}' not found.",
                    )
                message = f"Integration '{integration_name}' retrieved successfully."
                data = _MEMORY_INTEGRATION_CONFIG_STORE[integration_name]

        return MemoryIntegrationConfigResponse(success=True, message=message, data=data)

    except HTTPException as http_exc:
        # Propagate HTTPExceptions as they are
        raise http_exc
    except Exception as exc:
        # Unhandled exceptions are wrapped in a generic 500 response
        raise HTTPException(
            status_code=500,
            detail=f"MemoryIntegrationConfig execution failed: {str(exc)}",
        ) from exc


# Export router for main application
__all__ = ["router", "MemoryIntegrationConfigRequest", "MemoryIntegrationConfigResponse"]