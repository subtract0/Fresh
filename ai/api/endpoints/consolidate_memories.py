"""
API endpoint for consolidate_memories
Generated by Advanced Feature Stub Generator
"""
from fastapi import APIRouter, HTTPException, Depends
from pydantic import BaseModel, Field, validator
from typing import Optional, Dict, Any, List
from datetime import datetime

router = APIRouter()


class consolidate_memoriesRequest(BaseModel):
    """Request model for consolidate_memories."""
    data: Dict[str, Any] = Field(
        ...,
        description=(
            "Payload containing the memories to consolidate. "
            "Expected format: {'memories': [<str>, ...]}"
        ),
    )

    @validator("data")
    def validate_data(cls, value: Dict[str, Any]) -> Dict[str, Any]:
        """Validate that required keys exist and are of correct type."""
        if "memories" not in value:
            raise ValueError("Missing 'memories' key in request 'data'.")
        if not isinstance(value["memories"], list):
            raise ValueError("'memories' must be a list.")
        for item in value["memories"]:
            if not isinstance(item, str):
                raise ValueError("Each memory must be a string.")
        return value


class consolidate_memoriesResponse(BaseModel):
    """Response model for consolidate_memories."""
    success: bool
    message: str
    data: Optional[Dict[str, Any]] = None
    timestamp: datetime = Field(default_factory=datetime.utcnow)


def _consolidate_memories(memories: List[str]) -> Dict[str, Any]:
    """
    Consolidate a list of memory strings by removing duplicates
    while preserving insertion order.

    Args:
        memories: List of memory strings.

    Returns:
        Dict with original count, consolidated count and consolidated list.
    """
    seen = set()
    consolidated_list: List[str] = []
    for mem in memories:
        if mem not in seen:
            seen.add(mem)
            consolidated_list.append(mem)

    return {
        "original_count": len(memories),
        "consolidated_count": len(consolidated_list),
        "consolidated_memories": consolidated_list,
    }


@router.post(
    "/api/v1/consolidate-memories",
    response_model=consolidate_memoriesResponse,
    tags=["Memory"],
    summary="Consolidate duplicate memories",
)
async def consolidate_memories_endpoint(
    request: consolidate_memoriesRequest,
) -> consolidate_memoriesResponse:
    """
    Consolidate duplicate memories supplied in the request.

    The endpoint expects a JSON payload in the following structure:
    {
        "data": {
            "memories": ["memory1", "memory2", "memory1"]
        }
    }

    It returns the consolidated list without duplicates along with
    metadata about the consolidation process.
    """
    try:
        memories: List[str] = request.data["memories"]

        result_data = _consolidate_memories(memories)

        return consolidate_memoriesResponse(
            success=True,
            message="Memories consolidated successfully.",
            data=result_data,
        )

    except HTTPException:
        # Re-raise HTTPExceptions to be handled by FastAPI
        raise
    except Exception as exc:
        # Capture any unexpected errors and convert to HTTPException
        raise HTTPException(
            status_code=500,
            detail=f"Consolidate memories execution failed: {str(exc)}",
        ) from exc


# Export router for main application
__all__ = ["router", "consolidate_memoriesRequest", "consolidate_memoriesResponse"]