"""
API endpoint for track_write
Generated by Advanced Feature Stub Generator
"""
import logging
import threading
from datetime import datetime
from typing import Optional, Dict, Any, List

from fastapi import APIRouter, HTTPException
from pydantic import BaseModel, Field, validator

router = APIRouter()

# --------------------------------------------------------------------------- #
# Module-level logger setup
# --------------------------------------------------------------------------- #
logger = logging.getLogger(__name__)
if not logger.handlers:
    # Prevent duplicate handlers if the module is re-imported
    handler = logging.StreamHandler()
    formatter = logging.Formatter(
        fmt="%(asctime)s | %(levelname)s | %(name)s | %(message)s"
    )
    handler.setFormatter(formatter)
    logger.addHandler(handler)
logger.setLevel(logging.INFO)

# --------------------------------------------------------------------------- #
# In-memory storage and synchronization primitives
# --------------------------------------------------------------------------- #
_WRITE_OPERATION_LOG: List[Dict[str, Any]] = []
_LOG_LOCK = threading.Lock()


class track_writeRequest(BaseModel):
    """Request model for track_write.

    Attributes
    ----------
    operation : str
        A human-readable identifier for the write operation.
    user_id : Optional[str]
        Identifier of the user performing the operation.
    payload : Optional[Dict[str, Any]]
        The data written or attempted to be written.
    success : bool
        Indicates whether the write operation succeeded.
    error_message : Optional[str]
        Error message when `success` is False.
    metadata : Optional[Dict[str, Any]]
        Any additional metadata to track.
    """

    operation: str = Field(..., min_length=1, description="Name of the write operation")
    user_id: Optional[str] = Field(
        None, description="Identifier of the user performing the operation"
    )
    payload: Optional[Dict[str, Any]] = Field(
        None, description="Payload associated with the write operation"
    )
    success: bool = Field(..., description="Outcome of the write operation")
    error_message: Optional[str] = Field(
        None, description="Error message when the operation fails"
    )
    metadata: Optional[Dict[str, Any]] = Field(
        None, description="Additional tracking metadata"
    )

    # Backward compatibility for existing field `data`
    data: Optional[Dict[str, Any]] = Field(
        None,
        description="Deprecated: Use `payload` instead. Will be used if `payload` not provided.",
    )

    @validator("error_message", always=True)
    def validate_error_message(cls, v, values):
        """Ensure error_message is present if success is False, absent otherwise."""
        success = values.get("success", True)
        if not success and not v:
            raise ValueError("error_message is required when success is False")
        if success and v:
            raise ValueError("error_message must be omitted when success is True")
        return v

    @validator("payload", always=True)
    def fallback_to_data(cls, v, values):
        """If `payload` is not provided but deprecated `data` is, use that."""
        if v is None:
            data = values.get("data")
            if data is not None:
                logger.warning(
                    "`data` field is deprecated. Prefer `payload` instead."
                )
                return data
        return v


class track_writeResponse(BaseModel):
    """Response model for track_write."""

    success: bool
    message: str
    data: Optional[Dict[str, Any]] = None
    timestamp: datetime = Field(default_factory=datetime.utcnow)


def _store_write_record(record: Dict[str, Any]) -> None:
    """
    Store a write-operation record in the in-memory store.

    Parameters
    ----------
    record : Dict[str, Any]
        The record representing the write operation.
    """
    with _LOG_LOCK:
        _WRITE_OPERATION_LOG.append(record)
    logger.info("Stored write operation record: %s", record)


@router.post("/api/v1/track-write", response_model=track_writeResponse)
async def track_write_endpoint(request: track_writeRequest) -> track_writeResponse:
    """
    Endpoint to track write operations performed in the system.

    The endpoint records metadata about each write attempt, allowing for
    monitoring and later analysis.

    Parameters
    ----------
    request : track_writeRequest
        The incoming request containing operation details.

    Returns
    -------
    track_writeResponse
        Response confirming whether the tracking succeeded.
    """
    try:
        record = {
            "operation": request.operation,
            "user_id": request.user_id,
            "payload": request.payload,
            "success": request.success,
            "error_message": request.error_message,
            "metadata": request.metadata,
            "timestamp": datetime.utcnow().isoformat(),
        }

        _store_write_record(record)

        return track_writeResponse(
            success=True,
            message="Write operation tracked successfully",
            data=record,
        )

    except ValueError as ve:
        logger.error("Validation error while tracking write: %s", ve)
        raise HTTPException(status_code=422, detail=str(ve)) from ve
    except Exception as exc:
        logger.exception("Unexpected error while tracking write: %s", exc)
        raise HTTPException(
            status_code=500, detail="Internal Server Error"
        ) from exc


# Export router for main application
__all__ = ["router", "track_writeRequest", "track_writeResponse"]