"""
API endpoint for track_completion
Generated by Advanced Feature Stub Generator
"""
from __future__ import annotations

import json
import os
from datetime import datetime
from typing import Optional, Dict, Any, List

from fastapi import APIRouter, HTTPException
from pydantic import BaseModel, Field, validator

router = APIRouter()

# --------------------------------------------------------------------------- #
# Configuration
# --------------------------------------------------------------------------- #
_COMPLETION_LOG_FILE: str = os.getenv("TRACK_COMPLETION_STORE", "completion_log.json")


# --------------------------------------------------------------------------- #
# Utility helpers
# --------------------------------------------------------------------------- #
def _load_log() -> List[Dict[str, Any]]:
    """Load the completion log from disk, returning an empty list if file missing."""
    if not os.path.isfile(_COMPLETION_LOG_FILE):
        return []
    try:
        with open(_COMPLETION_LOG_FILE, "r", encoding="utf-8") as f:
            data = json.load(f)
        if isinstance(data, list):
            return data
        return []
    except (json.JSONDecodeError, OSError):
        # Corrupted file or read error; start fresh to avoid crashing the API.
        return []


def _save_log(entries: List[Dict[str, Any]]) -> None:
    """Persist the completion log to disk atomically."""
    tmp_path = f"{_COMPLETION_LOG_FILE}.tmp"
    try:
        with open(tmp_path, "w", encoding="utf-8") as f:
            json.dump(entries, f, ensure_ascii=False, indent=2, default=str)
        os.replace(tmp_path, _COMPLETION_LOG_FILE)
    except OSError as exc:
        # Re-raise as HTTPException to inform the client while maintaining API contract.
        raise HTTPException(
            status_code=500,
            detail=f"Failed to persist completion data: {exc}",
        ) from exc


# --------------------------------------------------------------------------- #
# Request / Response models
# --------------------------------------------------------------------------- #
class track_completionRequest(BaseModel):
    """
    Request model for track_completion.

    Fields
    ------
    user_id : str
        A unique identifier for the user completing the action.
    completion_id : str
        A unique identifier for the completion event (e.g., lesson ID).
    metadata : dict | None
        Optional arbitrary key-value data with extra context.
    timestamp : datetime | None
        Optional event timestamp. Defaults to current UTC time.
    data : dict | None
        Backwards-compatibility field that mirrors metadata when provided.
    """

    user_id: str = Field(..., min_length=1, description="Unique user identifier")
    completion_id: str = Field(..., min_length=1, description="Unique completion identifier")
    metadata: Optional[Dict[str, Any]] = Field(
        default=None, description="Optional extra context for the completion event"
    )
    timestamp: Optional[datetime] = Field(
        default_factory=datetime.utcnow,
        description="Timestamp of completion; defaults to server time",
    )
    # Legacy / generic payload support
    data: Optional[Dict[str, Any]] = Field(
        default=None, description="Deprecated field; use `metadata` instead"
    )

    @validator("timestamp", pre=True, always=True)
    def _ensure_datetime(cls, v):  # noqa: D401
        """Ensure timestamp is a datetime object."""
        if isinstance(v, str):
            try:
                return datetime.fromisoformat(v)
            except ValueError as exc:
                raise ValueError("timestamp must be ISO-8601 formatted") from exc
        return v

    @validator("metadata", always=True)
    def _fallback_to_data(cls, v, values):  # noqa: D401
        """Fallback to `data` field if metadata missing."""
        if v is None and "data" in values and values["data"] is not None:
            return values["data"]
        return v


class track_completionResponse(BaseModel):
    """Response model for track_completion."""

    success: bool
    message: str
    data: Optional[Dict[str, Any]] = None
    timestamp: datetime = Field(default_factory=datetime.utcnow)


# --------------------------------------------------------------------------- #
# Endpoint
# --------------------------------------------------------------------------- #
@router.post(
    "/api/v1/track-completion",
    response_model=track_completionResponse,
    summary="Track user completion events",
    tags=["tracking"],
)
async def track_completion_endpoint(
    request: track_completionRequest,
) -> track_completionResponse:
    """
    Persist a completion event and return updated metrics.

    The endpoint records the completion event in a local JSON file and returns
    basic metrics, such as the total number of completion events recorded for
    the given user and globally.
    """
    try:
        # Normalize and prepare event data.
        event = {
            "user_id": request.user_id,
            "completion_id": request.completion_id,
            "metadata": request.metadata or {},
            "timestamp": request.timestamp.isoformat(),
        }

        # Load existing log, append, and persist.
        log_entries = _load_log()
        log_entries.append(event)
        _save_log(log_entries)

        # Compute simple metrics.
        user_total = sum(1 for entry in log_entries if entry["user_id"] == request.user_id)
        global_total = len(log_entries)

        result_data = {
            "event_recorded": event,
            "metrics": {
                "user_total_completions": user_total,
                "global_total_completions": global_total,
            },
        }

        return track_completionResponse(
            success=True,
            message="Completion event recorded successfully",
            data=result_data,
        )

    except HTTPException:
        # Re-raise HTTP exceptions without modification.
        raise
    except Exception as exc:  # pragma: no cover
        raise HTTPException(
            status_code=500,
            detail=f"track_completion execution failed: {exc}",
        ) from exc


# Export router for main application
__all__ = ["router", "track_completionRequest", "track_completionResponse"]