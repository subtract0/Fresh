"""
API endpoint for MemorySync
Generated by Advanced Feature Stub Generator
"""
from datetime import datetime, timezone
from typing import Optional, Dict, Any

from fastapi import APIRouter, HTTPException
from pydantic import BaseModel, Field, root_validator

router = APIRouter()


class MemorySyncRequest(BaseModel):
    """Request model for MemorySync."""
    source_store: str = Field(..., description="Name of the source memory store")
    destination_store: str = Field(..., description="Name of the destination memory store")
    overwrite: bool = Field(
        False,
        description="Whether to overwrite existing keys in the destination store"
    )
    data: Optional[Dict[str, Any]] = Field(
        None,
        description="Optional data to merge into the source store before syncing"
    )

    @root_validator
    def validate_stores(cls, values: Dict[str, Any]) -> Dict[str, Any]:
        """Ensure source and destination stores are not identical."""
        if values.get("source_store") == values.get("destination_store"):
            raise ValueError("source_store and destination_store must be different")
        return values


class MemorySyncResponse(BaseModel):
    """Response model for MemorySync."""
    success: bool
    message: str
    data: Optional[Dict[str, Any]] = None
    timestamp: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))


class InMemoryStore:
    """
    Simple in-process memory store simulator.
    Provides isolated dictionaries per store name and synchronisation utilities.
    """
    _stores: Dict[str, Dict[str, Any]] = {}

    @classmethod
    def get_store(cls, name: str) -> Dict[str, Any]:
        """
        Retrieve (or create) a named store.

        Args:
            name: The name of the store.

        Returns:
            The dictionary representing the store.
        """
        if name not in cls._stores:
            cls._stores[name] = {}
        return cls._stores[name]

    @classmethod
    def sync(
        cls,
        source: str,
        destination: str,
        overwrite: bool = False,
        data_update: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Synchronize data from source to destination.

        Args:
            source: Source store name.
            destination: Destination store name.
            overwrite: Whether to overwrite existing keys in destination.
            data_update: Data to merge into the source before syncing.

        Returns:
            Dict of keys that were transferred/updated in the destination.
        """
        if source == destination:
            raise ValueError("Cannot sync a store to itself")

        src_store = cls.get_store(source)
        dest_store = cls.get_store(destination)

        # Merge provided data into the source store before sync
        if data_update:
            src_store.update(data_update)

        changed: Dict[str, Any] = {}
        for key, value in src_store.items():
            if overwrite or key not in dest_store:
                dest_store[key] = value
                changed[key] = value

        return changed


@router.post("/api/v1/MemorySync", response_model=MemorySyncResponse)
async def memorysync_endpoint(
    request: MemorySyncRequest,
) -> MemorySyncResponse:
    """
    MemorySync endpoint.

    Synchronises memory between two named in-process stores. Optionally
    merges provided data into the source store prior to synchronisation.

    Raises:
        HTTPException (400): Validation or user error.
        HTTPException (500): Unhandled server error.
    """
    try:
        changes = InMemoryStore.sync(
            source=request.source_store,
            destination=request.destination_store,
            overwrite=request.overwrite,
            data_update=request.data,
        )

        return MemorySyncResponse(
            success=True,
            message="MemorySync executed successfully",
            data={
                "source_store": request.source_store,
                "destination_store": request.destination_store,
                "keys_synced": list(changes.keys()),
                "overwrite": request.overwrite,
            },
        )
    except ValueError as ve:
        # Known validation error
        raise HTTPException(status_code=400, detail=str(ve)) from ve
    except Exception as e:  # pragma: no cover
        # Unhandled error
        raise HTTPException(
            status_code=500, detail=f"MemorySync execution failed: {str(e)}"
        ) from e


# Export router for main application
__all__ = ["router", "MemorySyncRequest", "MemorySyncResponse"]