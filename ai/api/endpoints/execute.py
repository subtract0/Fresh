"""
API endpoint for execute
Generated by Advanced Feature Stub Generator
"""
from fastapi import APIRouter, HTTPException, Depends, Header, status
from pydantic import BaseModel, Field, validator
from typing import Optional, Dict, Any
from datetime import datetime
import os

router = APIRouter()


class executeRequest(BaseModel):
    """Request model for execute."""
    command: str = Field(..., description="The command to execute")
    params: Optional[Dict[str, Any]] = Field(
        default_factory=dict,
        description="Optional parameters for the command"
    )

    @validator("command")
    def command_must_not_be_empty(cls, v: str) -> str:
        """Ensure the command string is not empty or blank."""
        if not v or not v.strip():
            raise ValueError("Command must be a non-empty string.")
        return v.strip().lower()


class executeResponse(BaseModel):
    """Response model for execute."""
    success: bool
    message: str
    data: Optional[Dict[str, Any]] = None
    timestamp: datetime = Field(default_factory=datetime.utcnow)


def _authorize_request(
    authorization: Optional[str] = Header(None, description="Bearer authorization token")
) -> None:
    """
    Simple authorization dependency. If EXECUTE_API_TOKEN is set in the environment,
    the request must include a matching Bearer token. Otherwise, the endpoint is open.
    """
    expected_token = os.getenv("EXECUTE_API_TOKEN")
    if expected_token:
        if not authorization or not authorization.startswith("Bearer "):
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Authorization header missing or malformed."
            )
        token = authorization.removeprefix("Bearer ").strip()
        if token != expected_token:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Invalid authorization token."
            )


def _handle_command(command: str, params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Internal dispatcher that maps supported commands to their handlers.
    Extend this function to add new commands.
    """
    if command == "ping":
        return {"response": "pong"}
    if command == "echo":
        message = params.get("message")
        if message is None:
            raise HTTPException(
                status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
                detail="`echo` command requires a `message` parameter."
            )
        return {"echo": message}
    if command == "datetime":
        return {"datetime": datetime.utcnow().isoformat() + "Z"}

    # Unknown command
    raise HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=f"Unsupported command '{command}'."
    )


@router.post(
    "/api/v1/execute",
    response_model=executeResponse,
    status_code=status.HTTP_200_OK,
    tags=["execute"],
    summary="Execute a command"
)
async def execute_endpoint(
    request: executeRequest,
    _: None = Depends(_authorize_request)
) -> executeResponse:
    """
    Execute endpoint.
    Processes incoming commands and returns the result.
    Available commands:
      - ping: healthcheck, returns 'pong'
      - echo: returns back the provided message (`params.message`)
      - datetime: returns current UTC datetime in ISO format
    """
    try:
        result_data = _handle_command(request.command, request.params or {})
        return executeResponse(
            success=True,
            message="Command executed successfully.",
            data=result_data
        )

    except HTTPException:
        # Re-raise to allow FastAPI to handle custom HTTP errors
        raise
    except Exception as exc:
        # Catch-all for unexpected errors
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Internal server error: {str(exc)}"
        ) from exc


# Export router for main application
__all__ = ["router", "executeRequest", "executeResponse"]