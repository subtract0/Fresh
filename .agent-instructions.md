# Agent Instructions for Fresh AI System

> **For Autonomous AI Agents**  
> **Last Updated**: 2025-09-05  
> **Codebase**: Fresh AI Enhanced Agent System v0.1.0

---

## 🎯 Understanding This Codebase

### Start Here
1. **Project Manifest**: `.documentation/manifest.json` - Complete feature map and structure
2. **Feature Status**: `docs/FEATURE_STATUS.md` - What's actually implemented vs planned  
3. **Architecture**: `docs/ARCHITECTURE.md` - System design overview
4. **Memory System**: `docs/MEMORY_SYSTEM.md` - Core persistent memory architecture

### Navigation Patterns  
```
Fresh/
├── ai/                    # Core AI system
│   ├── memory/           # Persistent memory system (CORE)
│   ├── agents/           # Enhanced agents with memory (CORE)  
│   ├── tools/            # Memory tools and utilities (SUPPORTING)
│   ├── cli/              # Command-line interface (INTERFACE)
│   ├── interface/        # Telegram, web interfaces (INTERFACE)
│   ├── integration/      # GitHub, MCP integrations (SUPPORTING)
│   ├── loop/             # Development cycle automation (SUPPORTING)
│   ├── monitor/          # System monitoring (SUPPORTING)
│   └── workflows/        # Workflow automation (SUPPORTING)
├── docs/                 # Project documentation
├── tests/                # Test suite
└── scripts/              # Automation scripts
```

### Feature Classification
- **CORE**: Essential system functionality (memory, agents, tools)
- **INTERFACE**: User/external system interaction points  
- **SUPPORTING**: Optional enhancements and utilities

---

## 🚀 Making Changes

### Pre-Change Protocol
1. **Check Dependencies**: Review `.documentation/manifest.json` for feature dependencies
2. **Read Documentation**: Check feature-specific README and docs
3. **Run Tests**: Ensure you understand current behavior via tests
4. **Verify Status**: Confirm feature is fully implemented in `docs/FEATURE_STATUS.md`

### Change Process
```bash
# 1. Create feature branch
git checkout -b feature/your-feature-name

# 2. Update documentation FIRST (TDD for docs)
# - Add/update feature README  
# - Update .documentation/manifest.json
# - Add file headers with @file, @description, @usage

# 3. Implement changes
# - Follow existing patterns in feature directory
# - Update tests alongside implementation
# - Ensure backward compatibility

# 4. Validate changes  
python scripts/validate_documentation.py
poetry run pytest tests/ -q
python scripts/analyze_feature_status.py

# 5. Professional commit and PR
git add .
git commit -m "feat: descriptive commit message

- What you changed and why
- Reference any ADRs (ADR-XXX)
- Note any breaking changes"

git push -u origin feature/your-feature-name
gh pr create --title "feat: Feature Name" --body "Description"
```

### Post-Change Requirements
- ✅ All tests passing
- ✅ Documentation updated and accurate  
- ✅ `.documentation/manifest.json` reflects changes
- ✅ No orphaned files created
- ✅ File headers complete

---

## 📋 Documentation Standards

### File Header Template
```python
"""
@file filename.py
@description Brief description of what this file does and why it exists

@connections
- imports: List key imports and why they're needed
- exports: List public exports and their purpose
- implements: Any interfaces or contracts this implements

@usage
```python
# Example usage code here
```

@notes  
- Important implementation details
- Gotchas or warnings
- Performance considerations

@see
- related_file.py - How they relate
- docs/GUIDE.md#section - Relevant documentation  

@since v0.1.0
"""
```

### README Structure (for feature directories)
```markdown
# Feature: [Feature Name]

## Purpose
One-sentence description of what this feature does.

## Components
- `file1.py` - Brief description
- `file2.py` - Brief description

## Usage
```python
# Core usage example
from ai.feature import MainClass
instance = MainClass()
result = instance.main_method()
```

## Dependencies
- **Internal**: Other Fresh features this depends on
- **External**: Third-party packages required  

## Testing
```bash
poetry run pytest tests/test_feature_name.py -v
```

## Architecture
Brief overview of how components work together.
```

---

## 🧠 Memory System Integration

### Memory-First Development
Every agent should leverage the persistent memory system:

```python
# Always check memory before implementing
from ai.tools.enhanced_memory_tools import SemanticSearchMemory
search = SemanticSearchMemory(keywords=["similar", "task", "pattern"])
similar_work = search.run()

# Learn from past patterns
# ... implement using insights ...

# Store new learnings  
from ai.tools.enhanced_memory_tools import SmartWriteMemory
SmartWriteMemory(
    content="Learned: Pattern X works better than Y for Z because...",
    tags=["knowledge", "pattern", "feature-name"]
).run()
```

### Memory Types
- **GOAL**: Strategic objectives and high-level plans
- **TASK**: Specific implementation tasks and TODOs  
- **DECISION**: Architecture decisions and rationale (link to ADRs)
- **ERROR**: Bugs, failures, and their solutions
- **KNOWLEDGE**: Insights, patterns, and lessons learned
- **PROGRESS**: Status updates and completion tracking
- **CONTEXT**: Environmental and configuration information

---

## ⚠️ Quality Gates

### Before Any Commit
```bash
# Documentation validation
python scripts/validate_documentation.py

# Test suite  
poetry run pytest tests/ -q

# Feature status check
python scripts/analyze_feature_status.py
```

### Red Flags (Stop and Fix)
- ❌ Orphaned files (not referenced anywhere)
- ❌ Missing file headers (@file, @description, @usage)
- ❌ Broken imports or circular dependencies
- ❌ Tests failing
- ❌ Documentation out of sync with code

### Success Criteria
- ✅ All files have complete headers
- ✅ Every feature directory has README
- ✅ All public APIs documented with examples  
- ✅ Tests cover new functionality
- ✅ `.documentation/manifest.json` updated

---

## 🔧 Common Tasks

### Add New Feature
```bash
# 1. Create feature directory structure
mkdir -p ai/new_feature
cd ai/new_feature

# 2. Copy template structure
cp -r ../../.templates/feature/* .

# 3. Update manifest
# Edit .documentation/manifest.json to add feature entry

# 4. Implement with TDD
# Write tests first, then implement
```

### Debug Integration Issues  
```bash
# 1. Check dependencies
python -c "
import json
with open('.documentation/manifest.json') as f:
    data = json.load(f)
    print('Feature dependencies:')
    for name, info in data['features'].items():
        if info.get('dependencies', {}).get('internal'):
            print(f'{name}: {info[\"dependencies\"][\"internal\"]}')
"

# 2. Trace imports
python scripts/analyze_dependencies.py feature_name

# 3. Check for circular dependencies  
python scripts/detect_circular_imports.py
```

### Update Documentation
```bash
# 1. Regenerate manifest
python scripts/update_documentation_manifest.py

# 2. Validate all links and references
python scripts/validate_documentation.py --strict

# 3. Update feature status
python scripts/analyze_feature_status.py --update
```

---

## 🎯 Success Metrics

### Code Quality
- **Documentation Coverage**: >90% of files have complete headers
- **Feature Coverage**: 100% of features have READMEs
- **Test Coverage**: Critical paths covered, not just line coverage
- **Reference Coverage**: 0 orphaned files

### Agent Readiness  
- **Navigation**: Can AI agent find any feature quickly via manifest
- **Understanding**: Clear purpose and API for every component
- **Modification**: Safe to change with clear impact analysis
- **Learning**: Memory system captures insights for future improvements

---

## 🚨 Emergency Procedures

### Broken Build
1. Check recent commits: `git log --oneline -10`
2. Run full test suite: `poetry run pytest tests/ -v`  
3. Check documentation alignment: `python scripts/validate_documentation.py`
4. If needed, revert: `git revert HEAD`

### Lost in Codebase
1. Start with `.documentation/manifest.json`
2. Find your feature in the features section
3. Check the `purpose` and `files` for that feature
4. Read the feature's README for detailed guidance

### Documentation Out of Sync
1. Run analysis: `python scripts/analyze_documentation_gaps.py`
2. Fix gaps systematically starting with missing READMEs
3. Update file headers for incomplete documentation
4. Regenerate manifest: `python scripts/update_documentation_manifest.py`

---

*Remember: Documentation is not just for humans—it's the foundation that enables autonomous AI development. Every line of documentation makes the system more intelligent and self-improving.*

**🤖 Happy autonomous developing!**
