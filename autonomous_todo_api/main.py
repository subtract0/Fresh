#!/usr/bin/env python3
"""
FastAPI Todo Management API

A production-ready REST API for managing todo items with SQLite database,
comprehensive testing, and full CRUD operations.

Generated by AAWOS (Autonomous AI Workflow System)
"""

from fastapi import FastAPI, HTTPException, Depends, status
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from sqlalchemy.orm import Session
from typing import List
import uvicorn

from database import get_db, create_tables
from models import TodoCreate, TodoUpdate, TodoResponse, TodoItem

# Initialize FastAPI application
app = FastAPI(
    title="Todo Management API",
    description="A production-ready REST API for managing todo items",
    version="1.0.0",
    docs_url="/docs",
    redoc_url="/redoc"
)

# Configure CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Configure appropriately for production
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Create database tables on startup
create_tables()

@app.get("/", response_model=dict)
def root():
    """Root endpoint providing API information."""
    return {
        "message": "Todo Management API",
        "version": "1.0.0",
        "docs": "/docs",
        "endpoints": [
            "GET /todos - Get all todos",
            "POST /todos - Create a new todo",
            "GET /todos/{id} - Get a specific todo",
            "PUT /todos/{id} - Update a todo",
            "DELETE /todos/{id} - Delete a todo"
        ]
    }

@app.get("/health", response_model=dict)
def health_check():
    """Health check endpoint."""
    return {"status": "healthy", "service": "todo-api"}

@app.get("/todos", response_model=List[TodoResponse])
def get_todos(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    """
    Retrieve all todos with optional pagination.
    
    Args:
        skip: Number of todos to skip (default: 0)
        limit: Maximum number of todos to return (default: 100)
        db: Database session
        
    Returns:
        List of todos
    """
    todos = db.query(TodoItem).offset(skip).limit(limit).all()
    return todos

@app.post("/todos", response_model=TodoResponse, status_code=status.HTTP_201_CREATED)
def create_todo(todo: TodoCreate, db: Session = Depends(get_db)):
    """
    Create a new todo item.
    
    Args:
        todo: Todo creation data
        db: Database session
        
    Returns:
        Created todo item
    """
    db_todo = TodoItem(**todo.model_dump())
    db.add(db_todo)
    db.commit()
    db.refresh(db_todo)
    return db_todo

@app.get("/todos/{todo_id}", response_model=TodoResponse)
def get_todo(todo_id: int, db: Session = Depends(get_db)):
    """
    Retrieve a specific todo by ID.
    
    Args:
        todo_id: ID of the todo to retrieve
        db: Database session
        
    Returns:
        Todo item
        
    Raises:
        HTTPException: If todo not found
    """
    todo = db.query(TodoItem).filter(TodoItem.id == todo_id).first()
    if todo is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Todo with id {todo_id} not found"
        )
    return todo

@app.put("/todos/{todo_id}", response_model=TodoResponse)
def update_todo(todo_id: int, todo_update: TodoUpdate, db: Session = Depends(get_db)):
    """
    Update an existing todo item.
    
    Args:
        todo_id: ID of the todo to update
        todo_update: Todo update data
        db: Database session
        
    Returns:
        Updated todo item
        
    Raises:
        HTTPException: If todo not found
    """
    db_todo = db.query(TodoItem).filter(TodoItem.id == todo_id).first()
    if db_todo is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Todo with id {todo_id} not found"
        )
    
    # Update only provided fields
    update_data = todo_update.model_dump(exclude_unset=True)
    for field, value in update_data.items():
        setattr(db_todo, field, value)
    
    db.commit()
    db.refresh(db_todo)
    return db_todo

@app.delete("/todos/{todo_id}", response_model=dict)
def delete_todo(todo_id: int, db: Session = Depends(get_db)):
    """
    Delete a todo item.
    
    Args:
        todo_id: ID of the todo to delete
        db: Database session
        
    Returns:
        Deletion confirmation
        
    Raises:
        HTTPException: If todo not found
    """
    db_todo = db.query(TodoItem).filter(TodoItem.id == todo_id).first()
    if db_todo is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Todo with id {todo_id} not found"
        )
    
    db.delete(db_todo)
    db.commit()
    return {"message": f"Todo with id {todo_id} deleted successfully"}

@app.exception_handler(Exception)
async def global_exception_handler(request, exc):
    """Global exception handler for unhandled exceptions."""
    return JSONResponse(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        content={"detail": "Internal server error occurred"}
    )

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000, reload=True)
